---
title: "norepeat_noclimate"
output: html_document
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(purrr)
library(tidyr)
```


#{.tabset}

##Setup/Assumptions

Experiment: Simulate an initial stock assessment in Year 1 using catch-based data with varied amounts of error around the estimate of biomass. Make a decision on the harvest control rule based on estimate of biomass from the stock assessment. Apply that rule to the fishing mortality in year 1 and never repeat for the remainder of the simulation.

Assumptions: 
 - Fisheries represented in the model have no current management. Initial biomass in the simulation is therefore representative of the equilibrium that the fishery has reached over the years due to some level of fishing mortality (f). 
 - The current f at the beginning of the simulation is reached when catch is equivalent to the surplus production of the fishery at that biomass. 
 - The f calculated at the beginning of the simulation is the true fishing mortality rate of the operating fishery. 
 - There are no influences of climate change on this fishery 
 
 Goal: Simulate the initial use of FISHE, if it is only applied once and never repeated, focusing on the Inital Stock Assessment step of the process. 
 
 
##Model Error f/fmsy

Try the no climate no repeat model but instead of drawing b_err to find f_err to calculate f_ratio we just want to calculate the actual f_ratio and then draw a random ratio with some error

```{r model-fratio-error}

#Baseline model with error around the f_ratio (f/fmsy) and no repetition of the stock assessment process for the duration of the simulation:

sim_norep2 <- function(b, r, r_s, error, p, k, years){
  
  results <- data.frame(
    b = rep(NA, years), c = rep(NA, years), 
    year = 1:years, r = rep(NA, years),
    f_ratio = rep(NA, years), f_ratio_err = rep(NA, years)) #Setup the results dataframe 
  
  #Set the initial result for the outputs in year 1
  results$b[1] = b
  results$r[1] = r
  results$f[1] = (results$r[1] / p) * (1 - ((results$b[1] / k) ^ p)) #initial f assuming catch = surplus
  results$c[1] = results$f[1] * results$b[1] #using f based on initial biomass and actual initial biomass
  
  fmsy <-function(r,p){r * (1 / (1+p))} #set up the function to calculate Fmsy based on growth (r) and shape parameter (p)
  r_calc1 <- results$r[1]
  f_msy <- fmsy(r=r_calc1, p=p) #calculate fmsy in year 1
  results$f_ratio[1] = results$f[1]/f_msy #calculate the f_ratio using the f_err and fmsy
  results$f_ratio_err[1] = rnorm(1, mean = results$f_ratio[1], sd = (error*results$f_ratio[1]))
  
  
  ## Loop the model over the specified number of years
  # DO NOT REPEAT the initial stock assessment - make the HCR decision and apply the f to year 2, this f remains constant 
  for (t in 2:years) {
    if(results$year[t] == 2){
    
    results$r[t] = results$r[1] * (1 + (r_s*(t-1))) 
    
    ##HCR decision will change how f is calculated - this step must come before calculating c 
    # Calculate fmsy in time t from current r 
    r_calc2 <- results$r[t]
    f_msy[t] <- fmsy(r=r_calc2, p=p)
    
    #Decisions for f this year based on the ratio with error in the previous year 
    if(results$f_ratio_err[t-1] >= 2){
       results$f[t] = 0 #I think it makes sense for f to be zero the rest of the years but I don't know how to write that
   } 
    if(results$f_ratio_err[t-1] > 1 & results$f_ratio_err[t-1] < 2){
       results$f[t] = 0.9*results$f[t-1] #Reduce by 10% - same thing as keeping 90% of previous fishing mortality
   }  
    if(results$f_ratio_err[t-1] == 1){
       results$f[t] = results$f[t-1]  #f stays the same in as last year
   }
    if(results$f_ratio_err[t-1] < 1){
       results$f[t] = 1.05*results$f[t-1] #f increases by 5% from last year
   } 
    results$f_ratio[t] <- results$f[t]/f_msy[t] #the ratio of f/fmsy this year should be based on fishing pressure and msy from that year
    
    #Calculate remaining results - pay attention to the order!
    results$b[t] = results$b[t-1] + (results$r[t-1] / p)*results$b[t-1]*(1 - ((results$b[t-1]/k) ^ p))-results$c[t-1]
    results$f_ratio_err[t] = 0 #Don't want to redraw error this step only happens once in this simulation
    results$c[t] = results$f[t] * results$b[t]
   } 

  if(results$year[t] != 2){
    results$r[t] = results$r[1] * (1 + (r_s*(t-1)))
    results$b[t] = results$b[t-1] + (results$r[t-1] / p)*results$b[t-1]*(1 - ((results$b[t-1]/k) ^ p))-results$c[t-1]
    results$f[t] = results$f[2]
    results$c[t] = results$f[t] * results$b[t]
    results$f_ratio_err[t] = 0
    results$f_ratio[t] = 0
    
  }
}
  return(results)
}


```

##Model Check

Simple results check:
```{r simple-check-fratio-error}

check_result_fratio <- sim_norep2(b=6000, r=0.2, r_s=0, error=0.10, p=0.2, k=10000, years=100)
```

##Model Inputs List

Create the experiment input list:
```{r experiment-inputs}

#Design experiments
list_norep2 <- list(
  b = seq(1000, 10000, 1000),
  r = 0.2,
  r_s = 0,
  error = seq(0.05, 0.55, 0.05),
  p = 0.2,
  k = 10000,
  years = 100
)

input_norep2 <- list_norep2 %>%
  cross()


```


##Run

Run the model:
```{r run}

results = list()

#Run the model over the input lists:

for(i in 1:110){
  results[[i]] <- sim_norep2(b=input_norep2[[i]]$b, r=input_norep2[[i]]$r,
                             r_s=input_norep2[[i]]$r_s, p=input_norep2[[i]]$p,
                             k=input_norep2[[i]]$k,years=input_norep2[[i]]$years, 
                             error = input_norep2[[i]]$error)
}

```

Okay this ran and it worked for me on the first try (I ran the fmsy function first and then the complete function). I think it's doing what we want by calculating the actual fratio and then drawing a f/fmsy ratio with some error (may need to ask if this error should also be log normal because right now it is not). The model applies the estimated ratio with error (f_ratio_err) to the HCR decision tree and then uses that decision to change the actual f in the next year. This simulation only happens once and the decision made in year 2 is based on the ratios from year 1 but the HCR is applied to f in year 2 and f is held constant the rest of the simulation. 


##Save to CSV
```{r save-run2}

##Set Up - Need to create the first dataframe (results_edit) to feed into the loop:
col_df <- 7
col_names <- c("b", "c", "year", "r", "f_ratio", "f_ratio_err", "f")
col_names2 <- c("b", "c", "year", "r", "f_ratio", "f_ratio_err", "f", "id")

results_df <- as.data.frame(matrix(unlist(results[1]), ncol = 7))
colnames(results_df) <- col_names

results_edit <- results_df %>% 
  mutate(id = "exp1")

id_nums <- seq(1,110,1) #to help with pasting the correct id

#Now run the loop below

for(t in 2:110){
  
  if(t == 2){
  results_df <- as.data.frame(matrix(unlist(results[[2]]), ncol = 7))
  id <- paste("exp", id_nums[t], sep = "")
  results_df$id <- id
  colnames(results_df) <- col_names2
  results_norep[t] <- rbind(results_edit, results_df)
  }
  if(t > 2){
  id <- paste("exp", id_nums[t], sep = "")
  experiment[t] <- as.data.frame(matrix(unlist(results[[t]]), ncol = 7)) %>% 
    mutate(id = id)
  colnames(experiment[t]) <- col_names #I don't this part is working correctly with the [t] but I can't seem to fix it 
  results_norep[t] <- rbind(results_norep[t-1], experiment[t])
  }

  return(results_norep)
  
}

#This loop only works for t=2 and it gives me what I want but I can't figure out to generalize it for t>2; now I'm getting names do not match previous names but I don't know how to get the colnames to function with [t]
```



##OLD!

11.20 Sara: Commented this whole chunk out (command+shift+C) to avoid confusion. Testing a new model using error around the f/fmsy ratio; I moved this down and put the new code above. 
```{r model}

# #Baseline model with error around initial stock assessment and no repetition of the stock assessment process for the duration of the simulation:
# 
# sim_norep <- function(b, r, r_s, error, p, k, years){
#   
#   results <- data.frame(
#     b = rep(NA, years), c = rep(NA, years), 
#     year = 1:years, r = rep(NA, years), b_err = rep(NA, years),
#     f = rep(NA, years), f_ratio = rep(NA, years)) #Setup the results dataframe 
#   
#   #Set the initial result for the outputs in year 1
#   results$b[1] = b
#   results$b_err[1] = rnorm(1, mean = results$b[1], sd = (error*results$b[1])) #simulate error in initial stock assessment
#   results$r[1] = r
#   results$f[1] = (results$r[1] / p) * (1 - ((results$b[1] / k) ^ p)) #initial f is based on the actual initial biomass assuming catch=surplus production
#   results$c[1] = results$f[1] * results$b[1] #using f based on initial biomass and actual initial biomass
#   
#   fmsy <-function(r,p){r * (1 / (1+p))} #set up the function to calculate Fmsy based on growth (r) and shape parameter (p)
#   r_calc1 <- results$r[1]
#   f_msy <- fmsy(r=r_calc1, p=p) #calculate fmsy in year 1
#   f_err = (results$r[1] / p) * (1 - ((results$b_err[1] / k) ^ p)) #calculate the f the fishery thinks it has from their initial stock assessment with error
#   results$f_ratio[1] = f_err/f_msy #calculate the f_ratio using the f_err and fmsy 
#   
#   
#   ## Loop the model over the specified number of years
#   # DO NOT REPEAT the initial stock assessment - make the HCR decision and apply the f to year 2, this f remains constant 
#   for (t in 2:years) {
#     if(results$year[t] == 2){
#     
#     results$r[t] = results$r[1] * (1 + (r_s*(t-1))) 
#     
#     ##HCR decision will change how f is calculated - this step must come before calculating c 
#     # Calculate fmsy in time t from current r 
#     r_calc2 <- results$r[t]
#     f_msy[t] <- fmsy(r=r_calc2, p=p)
#     
#     #Decisions for f this year based on the ratio calucated this year 
#     if(results$f_ratio[t-1] >= 2){
#        results$f[t] = 0 #I think it makes sense for f to be zero the rest of the years but I don't know how to write that
#    } 
#     if(results$f_ratio[t-1] > 1 & results$f_ratio[t-1] < 2){
#        results$f[t] = 0.9*results$f[t-1] #Reduce by 10% - same thing as keeping 90% of previous fishing mortality
#    }  
#     if(results$f_ratio[t-1] == 1){
#        results$f[t] = results$f[t-1]  #f stays the same in as last year
#    }
#     if(results$f_ratio[t-1] < 1){
#        results$f[t] = 1.05*results$f[t-1] #f increases by 5% from last year
#    } 
#     results$f_ratio[t] <- results$f[t]/f_msy[t] #the ratio of f/fmsy this year should be based on fishing pressure and msy from that year
#     
#     #Calculate remaining results - pay attention to the order!
#     results$b[t] = results$b[t-1] + (results$r[t-1] / p)*results$b[t-1]*(1 - ((results$b[t-1]/k) ^ p))-results$c[t-1]
#     results$b_err[t] = 0 #Don't want to redraw error this step only happens once in this simulation
#     results$c[t] = results$f[t] * results$b[t]
#    } 
# 
#   if(results$year[t] != 2){
#     results$r[t] = results$r[1] * (1 + (r_s*(t-1)))
#     results$b[t] = results$b[t-1] + (results$r[t-1] / p)*results$b[t-1]*(1 - ((results$b[t-1]/k) ^ p))-results$c[t-1]
#     results$f[t] = results$f[2]
#     results$c[t] = results$f[t] * results$b[t]
#     results$b_err[t] = 0
#     results$f_ratio[t] = 0
#     
#   }
# }
#   return(results)
# }
# 


```
 
Simple results check:
```{r model-check}

#check_result <- sim_norep(b=6000, r=0.2, r_s=0, error=0.10, p=0.2, k=10000, years=100)

```


Create the experiment input list:
```{r experiment-inputs}

# #Design experiments
# list_norep <- list(
#   b = seq(1000, 10000, 1000),
#   r = 0.2,
#   r_s = 0,
#   error = seq(0.05, 0.55, 0.05),
#   p = 0.2,
#   k = 10000,
#   years = 100
# )
# 
# input_norep <- list_norep %>% 
#   cross()


```


Run the model:
```{r run}

# results = list()
# 
# #Run the model over the input lists:
# 
# for(i in 1:110){
#   results[[i]] <- sim_norep(b=input_norep[[i]]$b, r=input_norep[[i]]$r,
#                               r_s=input_norep[[i]]$r_s, p=input_norep[[i]]$p, 
#                               k=input_norep[[i]]$k,years=input_norep[[i]]$years, error = input_norep[[i]]$error)
# }

```

Getting an error - missing value where TRUE/FALSE needed from the first if statement. I will try some fixes on the test_intervals document to see if I can find the problem.  

Chase:
Tried problem solving this error. To me, the "missing value where TRUE/FALSE needed" seems to say that where it needs a value to say if the IF statement is true or false, it doesn't have one. Which I think means that it wasn't getting an initial f ratio. So, in the Fmsy and Ferr equation set up where we established the year 1 variables, the Fmsy function input used (r=r). I changed this to be r=results$r[1], and it worked. Im not sure if this is right but it seems to be working now. 


```{r save-to-csv}

# input_norep_df <- as.data.frame(matrix(unlist(input_norep), nrow = length(unlist(input_norep[110]))))
#         
# results_norep_df <- as.data.frame(matrix(unlist(results), nrow = length(unlist(results[110]))))
# 
# norep_df <- rbind(input_norep_df, results_norep_df)
# 
# norep_df_final <- data.frame(t(norep_df))
# 
# write.csv(norep_df_final, "G:/Data Analysis/SomefinFishE/FISHE_tests/stock_assessment_new/catch_tests/csv_results/norep_noclim.csv", row.names = FALSE)
# 
# #plot the results
# 
# for(i in 1:110){
#  plot(results[[i]]$b)
# }


```

Trying saving in long format:
```{r save2}
# #Dataframe of the inputs for each experiment:
# input_norep_df <- as.data.frame(matrix(unlist(input_norep), nrow = length(unlist(input_norep[110]))))
# 
# #want to change the scientific notation on one column so I know what we're working with:
# input_norep_df[1:110] <-format(input_norep_df[1:110], scientific = FALSE)
# 
# #In this format each column is a single experiment input in this order - b, r, r_s, error, p, k, years
# id <- c("b", "r", "r_s", "error", "p", "k", "years") #create a character vector of ids and put them in as row names
# 
# row.names(input_norep_df) <- id #add the id as row names
# colnames(input_norep_df)[1:110] <-gsub('[V]', "exp", colnames(input_norep_df)[1:110]) #add exp to the column headings instead of V
# 
# input_edit <- data.frame(t(input_norep_df))%>% 
#   mutate(id = row.names(input_edit)) 
# 
# #clean code but somewhat confusing ID
# input_edit_detail <- input_edit %>%  
#   unite("parameters", r, r_s, error, remove = FALSE)
# 
# #this one looks better but the code is kinda hacky
# input_detail_2 <- input_edit %>%
#   mutate(parameters = paste0(paste0(paste0(paste0(paste0("r=", r), ", r_s="), r_s), ", err="), error))

#This is a lengthy code but it gives a long dataframe with column names and an added row with an experiment identifier
## I think if we repeat this for the results and then merge them we might be able to tranpose it back into long format

```








