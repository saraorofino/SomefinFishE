---
title: "norepeat_noclimate"
output: html_document
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(purrr)
library(tidyr)
```


#{.tabset}

##Setup/Assumptions

Experiment: Simulate an initial stock assessment in Year 1 using catch-based data with varied amounts of error around the estimate of biomass. Make a decision on the harvest control rule based on estimate of biomass from the stock assessment. Apply that rule to the fishing mortality in year 1 and never repeat for the remainder of the simulation.

Assumptions: 
 - Fisheries represented in the model have no current management. Initial biomass in the simulation is therefore representative of the equilibrium that the fishery has reached over the years due to some level of fishing mortality (f). 
 - The current f at the beginning of the simulation is reached when catch is equivalent to the surplus production of the fishery at that biomass. 
 - The f calculated at the beginning of the simulation is the true fishing mortality rate of the operating fishery. 
 - There are no influences of climate change on this fishery 
 
 Goal: Simulate the initial use of FISHE, if it is only applied once and never repeated, focusing on the Inital Stock Assessment step of the process. 
 
 
 ##Model
```{r model}

#Baseline model with error around initial stock assessment and no repetition of the stock assessment process for the duration of the simulation:

sim_norep <- function(b, r, r_s, error, p, k, years){
  
  results <- data.frame(
    b = rep(NA, years), c = rep(NA, years), 
    year = 1:years, r = rep(NA, years), b_err = rep(NA, years),
    f = rep(NA, years), f_ratio = rep(NA, years)) #Setup the results dataframe 
  
  #Set the initial result for the outputs in year 1
  results$b[1] = b
  results$b_err[1] = rnorm(1, mean = results$b[1], sd = (error*results$b[1])) #simulate error in initial stock assessment
  results$r[1] = r
  results$f[1] = (results$r[1] / p) * (1 - ((results$b[1] / k) ^ p)) #initial f is based on the actual initial biomass assuming catch=surplus production
  results$c[1] = results$f[1] * results$b[1] #using f based on initial biomass and actual initial biomass
  
  fmsy <-function(r,p){r * (1 / (1+p))} #set up the function to calculate Fmsy based on growth (r) and shape parameter (p)
  r_calc1 <- results$r[1]
  f_msy <- fmsy(r=r_calc1, p=p) #calculate fmsy in year 1
  f_err = (results$r[1] / p) * (1 - ((results$b_err[1] / k) ^ p)) #calculate the f the fishery thinks it has from their initial stock assessment with error
  results$f_ratio[1] = f_err/f_msy #calculate the f_ratio using the f_err and fmsy 
  
  
  ## Loop the model over the specified number of years
  # DO NOT REPEAT the initial stock assessment - make the HCR decision and apply the f to year 2, this f remains constant 
  for (t in 2:years) {
    if(results$year[t] == 2){
    
    results$r[t] = results$r[1] * (1 + (r_s*(t-1))) 
    
    ##HCR decision will change how f is calculated - this step must come before calculating c 
    # Calculate fmsy in time t from current r 
    r_calc2 <- results$r[t]
    f_msy[t] <- fmsy(r=r_calc2, p=p)
    
    #Decisions for f this year based on the ratio calucated this year 
    if(results$f_ratio[t-1] >= 2){
       results$f[t] = 0 #I think it makes sense for f to be zero the rest of the years but I don't know how to write that
   } 
    if(results$f_ratio[t-1] > 1 & results$f_ratio[t-1] < 2){
       results$f[t] = 0.9*results$f[t-1] #Reduce by 10% - same thing as keeping 90% of previous fishing mortality
   }  
    if(results$f_ratio[t-1] == 1){
       results$f[t] = results$f[t-1]  #f stays the same in as last year
   }
    if(results$f_ratio[t-1] < 1){
       results$f[t] = 1.05*results$f[t-1] #f increases by 5% from last year
   } 
    results$f_ratio[t] <- results$f[t]/f_msy[t] #the ratio of f/fmsy this year should be based on fishing pressure and msy from that year
    
    #Calculate remaining results - pay attention to the order!
    results$b[t] = results$b[t-1] + (results$r[t-1] / p)*results$b[t-1]*(1 - ((results$b[t-1]/k) ^ p))-results$c[t-1]
    results$b_err[t] = 0 #Don't want to redraw error this step only happens once in this simulation
    results$c[t] = results$f[t] * results$b[t]
   } 

  if(results$year[t] != 2){
    results$r[t] = results$r[1] * (1 + (r_s*(t-1)))
    results$b[t] = results$b[t-1] + (results$r[t-1] / p)*results$b[t-1]*(1 - ((results$b[t-1]/k) ^ p))-results$c[t-1]
    results$f[t] = results$f[2]
    results$c[t] = results$f[t] * results$b[t]
    results$b_err[t] = 0
    results$f_ratio[t] = 0
    
  }
}
  return(results)
}



```
 
##Model Check

Quick check over a simple input to be sure the model runs properly:
```{r model-check}

check_result <- sim_norep(b=6000, r=0.2, r_s=0, error=0.10, p=0.2, k=10000, years=100)

```


##Model Inputs List

Create the experiment input list:
```{r experiment-inputs}

#Design experiments
list_norep <- list(
  b = seq(1000, 10000, 1000),
  r = 0.2,
  r_s = 0,
  error = seq(0.05, 0.55, 0.05),
  p = 0.2,
  k = 10000,
  years = 100
)

input_norep <- list_norep %>% 
  cross()


```

##Run

```{r run}
#Run the model over the input lists:

for(i in 1:110){
  results[[i]] <- sim_norep(b=input_norep[[i]]$b, r=input_norep[[i]]$r,
                              r_s=input_norep[[i]]$r_s, p=input_norep[[i]]$p, 
                              k=input_norep[[i]]$k,years=input_norep[[i]]$years, error = input_norep[[i]]$error)
}

```

Getting an error - missing value where TRUE/FALSE needed from the first if statement. I will try some fixes on the test_intervals document to see if I can find the problem.  

Chase:
Tried problem solving this error. To me, the "missing value where TRUE/FALSE needed" seems to say that where it needs a value to say if the IF statement is true or false, it doesn't have one. Which I think means that it wasn't getting an initial f ratio. So, in the Fmsy and Ferr equation set up where we established the year 1 variables, the Fmsy function input used (r=r). I changed this to be r=results$r[1], and it worked. Im not sure if this is right but it seems to be working now. 

##Save to CSV

```{r save-to-csv}

input_norep_df <- as.data.frame(matrix(unlist(input_norep), nrow = length(unlist(input_norep[110]))))
        
results_norep_df <- as.data.frame(matrix(unlist(results), nrow = length(unlist(results[110]))))

norep_df <- rbind(input_norep_df, results_norep_df)

norep_df_final <- data.frame(t(norep_df))

write.csv(norep_df_final, "G:/Data Analysis/SomefinFishE/FISHE_tests/stock_assessment_new/catch_tests/csv_results/norep_noclim.csv", row.names = FALSE)

#plot the results

for(i in 1:110){
 plot(results[[i]]$b)
}


```

Trying saving in long format:
```{r save2}
#Dataframe of the inputs for each experiment:
input_norep_df <- as.data.frame(matrix(unlist(input_norep), nrow = length(unlist(input_norep[110]))))

#want to change the scientific notation on one column so I know what we're working with:
input_norep_df[1:110] <-format(input_norep_df[1:110], scientific = FALSE)

#In this format each column is a single experiment input in this order - b, r, r_s, error, p, k, years
id <- c("b", "r", "r_s", "error", "p", "k", "years") #create a character vector of ids and put them in as row names

row.names(input_norep_df) <- id #add the id as row names
colnames(input_norep_df)[1:110] <-gsub('[V]', "exp", colnames(input_norep_df)[1:110]) #add exp to the column headings instead of V

input_edit <- data.frame(t(input_norep_df)) %>% 
  mutate(id = row.names(input_edit))

#This is a lengthy code but it gives a long dataframe with column names and an added row with an experiment identifier
## I think if we repeat this for the results and then merge them we might be able to tranpose it back into long format

```

